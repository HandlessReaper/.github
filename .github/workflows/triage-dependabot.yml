name: Reusable – Dependabot Auto-Triage

on:
  workflow_call:
    inputs:
      repo:
        required: true
        type: string

jobs:
  triage:
    name: Triage ${{ inputs.repo }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: read
      issues: write
    env:
      GH_TOKEN: ${{ github.token }}   # für gh api

    steps:
      - name: Checkout target repo
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo }}
          fetch-depth: 0

      - name: Install scanners (nur wenn nötig, rekursiv)
        run: |
          if find . -name package.json | grep -q .; then
            echo "-> JS/TS erkannt, installiere depcheck"
            sudo npm i -g depcheck
          fi
          if find . -name requirements.txt -o -name pyproject.toml | grep -q .; then
            echo "-> Python erkannt, installiere vulture + pip-check-unused"
            python -m pip install --upgrade pip
            python -m pip install vulture pip-check-unused
          fi
          if find . -name composer.json | grep -q .; then
            echo "-> PHP erkannt, installiere composer (optional: composer-unused)"
            sudo apt-get update -y && sudo apt-get install -y composer
            composer global require composer-unused/composer-unused --no-interaction || true
          fi
          if find . -name pom.xml -o -name build.gradle -o -name build.gradle.kts | grep -q .; then
            echo "-> Java erkannt (Maven/Gradle) – light Heuristik, kein Build"
          fi

      - name: Fetch Dependabot alerts (no dismiss, 404-freundlich)
        run: |
          mkdir -p triage
          set +e
          gh api -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" \
                 repos/${{ inputs.repo }}/dependabot/alerts -F per_page=100 --paginate \
                 > triage/alerts.json 2> triage/alerts.err
          rc=$?
          set -e
          if [ $rc -ne 0 ]; then
            if grep -qi "Not Found" triage/alerts.err; then
              echo "::warning::Dependabot alerts API 404 für ${{ inputs.repo }} – vermutlich nicht aktiviert. Fahre mit leerer Liste fort."
              echo "[]" > triage/alerts.json
            else
              echo "Fehler beim Abrufen der Alerts:"; cat triage/alerts.err || true
              exit $rc
            fi
          fi

      - name: Classify alerts (used/dev/dedupe inkl. Java light)
        shell: bash
        run: |
          python <<'PY'
          import os, json, subprocess, re, pathlib

          alerts = json.load(open("triage/alerts.json","r",encoding="utf-8"))

          # Spracherkennung (nur für Heuristiken)
          p = pathlib.Path(".")
          langs=set()
          if any(p.glob("**/package.json")): langs |= {"javascript","typescript"}
          if any(p.glob("**/requirements.txt")) or any(p.glob("**/pyproject.toml")): langs |= {"python"}
          if any(p.glob("**/composer.json")): langs |= {"php"}
          if any(p.glob("**/pom.xml")) or any(p.glob("**/build.gradle*")): langs |= {"java"}

          # JS/TS: depcheck (falls vorhanden)
          used_node=set()
          try:
              out = subprocess.run(["depcheck","--json"], capture_output=True, text=True, timeout=180)
              if out.returncode==0 and out.stdout.strip():
                  data = json.loads(out.stdout)
                  declared = set(data.get("dependencies",[])+data.get("devDependencies",[]))
                  unused = set(data.get("unusedDependencies",[])+data.get("unusedDevDependencies",[]))
                  used_node |= (declared - unused)
          except Exception:
              pass

          # --- naive Used-Scans pro Sprache ---
          def naive_used(pkg:str, eco:str)->bool:
              """Einfache Import-/Use-Muster in Code-Dateien.
                 Für Maven ist pkg oft 'groupId:artifactId' → splitten."""
              exts = (".js",".jsx",".ts",".tsx",".py",".php",".java",".kt",".kts",".rb")
              pats = [
                  rf"require\(['\"]{re.escape(pkg)}['\"]\)",
                  rf"from ['\"]{re.escape(pkg)}['\"]",
                  rf"import ['\"]{re.escape(pkg)}['\"]",
                  rf"import .* from ['\"]{re.escape(pkg)}['\"]",
                  rf"use {re.escape(pkg)}",
              ]
              if eco.lower()=="maven":
                  group, _, artifact = pkg.partition(":")
                  if group:
                      pats += [rf"import\s+{re.escape(group)}(\.|;)", rf"@Import\(['\"]{re.escape(group)}"]
                  if artifact:
                      artifact_simple = re.sub(r"[-_.]","",artifact)
                      pats += [rf"{re.escape(artifact)}", rf"{re.escape(artifact_simple)}"]
              cre = re.compile("|".join(pats))
              for root, dirs, files in os.walk("."):
                  r = root.replace("\\","/")
                  if any(x in r for x in ("/.git","/node_modules","/vendor","/dist","/build","/target",".idea",".gradle")):
                      continue
                  for fn in files:
                      if fn.endswith(exts):
                          try:
                              with open(os.path.join(root,fn),"r",encoding="utf-8",errors="ignore") as fh:
                                  if cre.search(fh.read(2_000_000)):
                                      return True
                          except Exception:
                              pass
              return False

          def sev_rank(s): 
              return {"critical":4,"high":3,"moderate":2,"medium":2,"low":1}.get((s or "").lower(),0)

          # Dedupe per (ecosystem, package, cve/ghsa)
          best={}
          for a in alerts:
              dep = a.get("dependency") or {}
              pkginfo = (dep.get("package") or {}) or ((a.get("security_advisory") or {}).get("package") or {})
              pkg = pkginfo.get("name") or ""
              eco = (pkginfo.get("ecosystem") or "").lower()
              adv = a.get("security_advisory") or {}
              sev = (adv.get("severity") or a.get("severity") or "")
              ghsa = adv.get("ghsa_id") or ""
              cve = ""
              for id_ in adv.get("identifiers",[]):
                  if id_.get("type")=="CVE":
                      cve = id_.get("value") or ""
                      break
              key=(eco,pkg,cve or ghsa)
              r = sev_rank(sev)
              if key not in best or r>best[key][0]:
                  best[key]=(r,a)

          kept, ignored = [], []
          for (_,_,_),(_,a) in best.items():
              dep = a.get("dependency") or {}
              pkginfo = (dep.get("package") or {}) or ((a.get("security_advisory") or {}).get("package") or {})
              pkg = pkginfo.get("name") or ""
              eco = (pkginfo.get("ecosystem") or "").lower()
              adv = a.get("security_advisory") or {}
              sev = (adv.get("severity") or a.get("severity") or "")
              manifest = dep.get("manifest_path") or ""
              url = a.get("html_url") or ""

              # Scope (dev?) – sicher für npm/pip; Java/PHP konservativ
              dev=False
              if eco in ("npm","pnpm","yarn") and manifest.endswith("package.json"):
                  try:
                      pj = json.load(open(manifest,"r",encoding="utf-8"))
                      if pkg in set((pj.get("devDependencies") or {}).keys()):
                          dev=True
                  except Exception:
                      pass
              if eco in ("pip","pypi") and ("dev" in manifest.lower() or "test" in manifest.lower()):
                  dev=True
              # Java light: wenn Pfad Hinweise auf tests hat → dev
              if eco in ("maven","gradle","github-actions-gradle","github-actions-maven"):
                  mp = manifest.lower()
                  if "test" in mp or "/tests/" in mp or "\\tests\\" in mp:
                      dev=True

              # Used?
              used=False
              if eco in ("npm","pnpm","yarn") and pkg in used_node:
                  used=True
              if not used:
                  used = naive_used(pkg, eco)

              row = {
                  "package": pkg,
                  "ecosystem": eco,
                  "severity": sev,
                  "manifest": manifest,
                  "url": url,
                  "dev": "yes" if dev else "no",
                  "used": "yes" if used else "no"
              }

              if not used:
                  row["reason"]="unused"
                  ignored.append(row)
              elif dev and (sev or "").lower() not in ("critical","high"):
                  row["reason"]="dev-noncritical"
                  ignored.append(row)
              else:
                  kept.append(row)

          pathlib.Path("triage").mkdir(exist_ok=True)
          json.dump(kept, open("triage/kept.json","w",encoding="utf-8"), indent=2, ensure_ascii=False)
          json.dump(ignored, open("triage/ignored.json","w",encoding="utf-8"), indent=2, ensure_ascii=False)
          PY

      - name: Mirror kept alerts to Issues (labelbar, ohne Dismiss)
        env:
          REPO: ${{ inputs.repo }}
        shell: bash
        run: |
          python - <<'PY'
          import json, os, subprocess

          repo = os.environ["REPO"]
          kept = json.load(open("triage/kept.json","r",encoding="utf-8"))

          def sh(*args):
              return subprocess.run(args, capture_output=True, text=True)

          for r in kept:
              title = f"[Dependabot Triage] {r.get('ecosystem','')}:{r.get('package','')} ({r.get('severity','')})"
              scope = "dev" if r.get("dev")=="yes" else "runtime/unknown"
              body = (
                  "Automatische Triage – Alert bleibt offen (kein Dismiss).\n\n"
                  f"- **Repo**: {repo}\n"
                  f"- **Paket**: `{r.get('package','')}` ({r.get('ecosystem','')})\n"
                  f"- **Severity**: {r.get('severity','')}\n"
                  f"- **Scope**: {scope}\n"
                  f"- **Used**: {r.get('used','')}\n"
                  f"- **Alert**: {r.get('url','')}\n\n"
                  "Bitte bewerten, Update/Workaround planen.\n"
              )
              labels = ["security","dependabot","needs-triage"]
              labels.append("dev" if scope=="dev" else "runtime")

              lst = sh("gh","issue","list","-R",repo,"--search",title,"--json","number,title")
              try:
                  existing = [i["title"] for i in json.loads(lst.stdout or "[]")]
              except Exception:
                  existing = []
              if title not in existing:
                  sh("gh","issue","create","-R",repo,"--title",title,"--body",body,"--label",",".join(labels))
          PY

      - name: Upload triage artifacts
        uses: actions/upload-artifact@v4
        with:
          name: triage-${{ inputs.repo }}
          path: triage/**
